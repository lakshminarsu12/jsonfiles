1. inside getUserMedia

function getFullVideoBlob() {
  if (!fullChunks.length) return null;
  return new Blob(fullChunks, { type: 'video/webm' });
}


async function extractLastSeconds(fullBlob, lastSeconds = 5) {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.style.display = 'none';
    video.muted = true;
    video.playsInline = true;

    document.body.appendChild(video);

    const url = URL.createObjectURL(fullBlob);
    video.src = url;

    video.onloadedmetadata = async () => {
      try {
        let dur = video.duration;

        // Some browsers report Infinity / NaN at first
        if (!isFinite(dur) || dur <= 0) {
          if (video.seekable && video.seekable.length > 0) {
            dur = video.seekable.end(video.seekable.length - 1);
          }
        }

        if (!isFinite(dur) || dur <= 0) {
          console.warn("Duration still invalid, using full video instead of last seconds");
          // As a fallback, just return the full video
          URL.revokeObjectURL(url);
          document.body.removeChild(video);
          resolve(fullBlob);
          return;
        }

        const clipLen = Math.min(lastSeconds, dur);
        const startTime = Math.max(0, dur - clipLen);
        video.currentTime = startTime;

        video.onseeked = async () => {
          try {
            const stream = video.captureStream();
            const rec = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            const chunks = [];

            rec.ondataavailable = e => {
              if (e.data && e.data.size > 0) chunks.push(e.data);
            };

            rec.onstop = () => {
              const outBlob = new Blob(chunks, { type: 'video/webm' });
              URL.revokeObjectURL(url);
              document.body.removeChild(video);
              resolve(outBlob);
            };

            rec.start();
            await video.play();

            setTimeout(() => {
              if (rec.state === 'recording') rec.stop();
              video.pause();
            }, clipLen * 1000);
          } catch (err) {
            reject(err);
          }
        };
      } catch (err) {
        reject(err);
      }
    };

    video.onerror = () => reject(new Error('Error loading video for trimming'));
  });
}



async function handleRgConfirmedAndUpload() {
  if (rgHandled) return;
  rgHandled = true;

  console.log("RG confirmed: stopping recorder and extracting last 5 seconds");

  // 1) Wait for recorder to fully stop and flush last chunk
  if (mediaRecorder && mediaRecorder.state === "recording") {
    await new Promise(resolve => {
      mediaRecorder.addEventListener('stop', () => resolve(), { once: true });
      mediaRecorder.stop();
    });
  }

  const fullBlob = getFullVideoBlob();
  if (!fullBlob) {
    console.warn("No full video data recorded");
    return;
  }

  try {
    // 2) Now safe to trim
    const last5Blob = await extractLastSeconds(fullBlob, BUFFER_SECONDS);

    // Optional: debug download
    const debugUrl = URL.createObjectURL(last5Blob);
    const a = document.createElement('a');
    a.href = debugUrl;
    a.download = 'last_5_seconds.webm';
    a.click();
    URL.revokeObjectURL(debugUrl);

    // 3) Upload as Base64
    const reader = new FileReader();
    reader.onloadend = function () {
      const dataUrl = reader.result;
      const base64Video = dataUrl.split(',')[1];

      fetch('http://localhost:9990/iapi/v1/aiService/uploadVideo?ban=1234', {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: base64Video
      })
      .then(res => res.text())
      .then(t => console.log('Upload last 5s response:', t))
      .catch(err => console.error('Upload last 5s error:', err));
    };
    reader.readAsDataURL(last5Blob);
  } catch (err) {
    console.error('Error extracting last 5 seconds:', err);
  }
}

