1Ô∏è‚É£ Ensure these globals exist near the top of <script>

Add these (or keep them if you already added similar ones):

// ---- Video ring-buffer for last N seconds ----
const BUFFER_SECONDS = 5;          // last 5 seconds
let mediaRecorder = null;
let recordedChunks = [];
let recordedTimes = [];

2Ô∏è‚É£ After getUserMedia succeeds, hook up MediaRecorder

Inside your existing:

navigator.mediaDevices.getUserMedia({
  video: {
    facingMode: { ideal: "environment" },
    zoom: 1.5
  },
  audio: false
}).then(stream => {
  preview.srcObject = stream;
  videoTrack = stream.getVideoTracks()[0];
  videoTrack.applyConstraints({
    advanced: [{ "exposureCompensation": -1 }]
  }); // Adjust exposure for better visibility


Add this block just after that:

  // --- Start MediaRecorder to keep a rolling buffer of video ---
  try {
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
  } catch (e) {
    console.warn('Falling back to default MediaRecorder options', e);
    mediaRecorder = new MediaRecorder(stream);
  }

  mediaRecorder.ondataavailable = (event) => {
    if (event.data && event.data.size > 0) {
      recordedChunks.push(event.data);
      recordedTimes.push(performance.now());

      // keep only last BUFFER_SECONDS of chunks
      const cutoff = performance.now() - BUFFER_SECONDS * 1000;
      while (recordedTimes.length && recordedTimes[0] < cutoff) {
        recordedTimes.shift();
        recordedChunks.shift();
      }
    }
  };

  // collect data every 500 ms
  mediaRecorder.start(500);


Leave the rest of the then block and the .catch as they are.

3Ô∏è‚É£ Add a helper to send LAST 5 SECONDS to your question API

Place this anywhere in the script (e.g. under the class definitions, before const ledDetector = ...):

// ---- Send last N seconds of video to question API as Base64 ----
function sendLastNSecondsToQuestionApi(nSeconds) {
  if (!recordedChunks.length) {
    console.warn('No recorded chunks yet, nothing to send');
    return;
  }

  const now = performance.now();
  const cutoff = now - nSeconds * 1000;

  const chunksToSend = [];
  for (let i = 0; i < recordedChunks.length; i++) {
    if (recordedTimes[i] >= cutoff) {
      chunksToSend.push(recordedChunks[i]);
    }
  }

  if (!chunksToSend.length) {
    console.warn('No chunks within the last ' + nSeconds + ' seconds');
    return;
  }

  const blob = new Blob(chunksToSend, { type: 'video/webm' });
  const reader = new FileReader();

  reader.onloadend = function () {
    const dataUrl = reader.result;                 // data:video/webm;base64,AAAA...
    const base64Video = dataUrl.split(',')[1];     // strip the prefix

    fetch('http://localhost:9990/iapi/v1/aiService/question?promptName=locateHWAny&ban=1234&encodedFlag=true', {
      method: 'POST',
      headers: {
        'Content-Type': 'text/plain'              // raw base64 in body
      },
      body: base64Video
    })
    .then(res => res.json())
    .then(response => {
      console.log('Question API response:', response);
      // You can also show it in the UI if you want:
      // document.getElementById('detectionResult').textContent = JSON.stringify(response);
    })
    .catch(err => {
      console.error('Error sending video to question API:', err);
      const el = document.getElementById('error-message');
      el.textContent = 'Error sending video: ' + (err.message || err);
    });
  };

  reader.readAsDataURL(blob);
}


If your backend doesn‚Äôt return JSON, replace res.json() with res.text().

4Ô∏è‚É£ Call this helper when RG is confirmed (instead of download)

Find this block in your existing processFrame() (you already have it):

if (rgDetector.lastMatchTime - rgDetector.firstMatchTime > 2000){
  console.log("RG Confirmed!, Notifing App");

  let ledStatus = ledDetector.getStatus();
  if (ledStatus){
    choosenColor = ledDetector.lastDetectedColor;
    choosenSpeed = ledStatus.solid ? "solid" : (ledStatus.hz > .66 ? "fast" : "slow");
  }else{
    choosenColor = "off";
    choosenSpeed = "uncertain";
  }

  let msg = JSON.stringify(
    {
      "rgIdentified": true,
      "rgModel": "BGW320",
      "leds": {
        "serviceLed": {
          "color": choosenColor,
          "speed": choosenSpeed
        },
        "wpsLed": {
          "color": "off",
          "speed": "uncertain"
        }
      }
    }
  );
  try{
    window.ReactNativeWebView.postMessage(msg);
  }catch(e){
  }
  try{
    window.ThinNative.postMessage(msg);
  }catch(e){
  }
  try{
    window.webkit.messageHandlers.nativeCallBack.postMessage(msg);
  }catch(e){
  }

  // ‚≠ê OLD: code that downloaded clip_last_5_seconds.webm ‚Äî REMOVE that.
}

// Send last 5 seconds of video to question API as Base64
  sendLastNSecondsToQuestionApi(BUFFER_SECONDS);
So the tail of the if (rgDetector.lastMatchTime - rgDetector.firstMatchTime > 2000) block becomes:

js
Copy code
  try{
    window.webkit.messageHandlers.nativeCallBack.postMessage(msg);
  }catch(e){
  }

  // Send last 5 seconds of video to question API as Base64
  sendLastNSecondsToQuestionApi(BUFFER_SECONDS);
}


  // -----------------------------
  // DEBUG: Download the video file
  // -----------------------------
  const debugUrl = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = debugUrl;
  a.download = 'clip_last_5_seconds.webm';   // File saved to your Downloads folder
  a.click();
  URL.revokeObjectURL(debugUrl);
  // -----------------------------
  // END DEBUG BLOCK
  // -----------------------------


  1. Add an array for the full recording
==========================================
Near the top of your script where you have:

const BUFFER_SECONDS = 5;          // last 5 seconds
let mediaRecorder = null;
let recordedChunks = [];
let recordedTimes = [];

change to:

const BUFFER_SECONDS = 5;          // last 5 seconds
let mediaRecorder = null;
let recordedChunks = [];           // rolling 5-second buffer
let recordedTimes = [];
let fullChunks = [];               // üëà all chunks from start (full video)

2. Store every chunk in fullChunks
====================================
In your navigator.mediaDevices.getUserMedia(...).then(stream => { ... })
you already have:

mediaRecorder.ondataavailable = (event) => {
  if (event.data && event.data.size > 0) {
    recordedChunks.push(event.data);
    recordedTimes.push(performance.now());

    const cutoff = performance.now() - BUFFER_SECONDS * 1000;
    while (recordedTimes.length && recordedTimes[0] < cutoff) {
      recordedTimes.shift();
      recordedChunks.shift();
    }
  }
};
Update it to also push into fullChunks:

mediaRecorder.ondataavailable = (event) => {
  if (event.data && event.data.size > 0) {
    // üîÅ 5-second buffer
    recordedChunks.push(event.data);
    recordedTimes.push(performance.now());

    const cutoff = performance.now() - BUFFER_SECONDS * 1000;
    while (recordedTimes.length && recordedTimes[0] < cutoff) {
      recordedTimes.shift();
      recordedChunks.shift();
    }

    // üßæ full recording
    fullChunks.push(event.data);
  }
};

3. Function to download the full video
===========================================
Add this function somewhere in your <script> (e.g. near sendLastNSecondsToQuestionApi):

function downloadFullVideo() {
  if (!fullChunks.length) {
    console.warn('No full recording yet');
    return;
  }

  const blob = new Blob(fullChunks, { type: 'video/webm' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = 'rg_full_recording.webm';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  URL.revokeObjectURL(url);

  // Optional: stop recording once we have the file
  // mediaRecorder.stop();
}

4. Call it when RG is confirmed
==================================
Find your RG-confirmed block (you already have):

Add the download call right after sendLastNSecondsToQuestionApi(...):

if (rgDetector.lastMatchTime - rgDetector.firstMatchTime > 2000){
  console.log("RG Confirmed!, Notifing App");

  // 1) Upload last 5 seconds to backend
  sendLastNSecondsToQuestionApi(BUFFER_SECONDS);

  // 2) Download full recording so far
  downloadFullVideo();

  let ledStatus = ledDetector.getStatus();
  ...
}




    // -------------------------------
    // START SEGMENT RECORDER (last 5s)
    // -------------------------------
    function startSegmentRecorder() {
        segmentChunks = [];

        segmentRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });

        segmentRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
                segmentChunks.push(event.data);
            }
        };

        segmentRecorder.onstop = () => {
            if (segmentChunks.length > 0) {
                // Now we have a valid 5-second standalone WebM!
                lastClipBlob = new Blob(segmentChunks, { type: 'video/webm' });
            }

            // Immediately start next 5-second segment
            startSegmentRecorder();
        };

        // Start segment and stop after BUFFER_SECONDS
        segmentRecorder.start();
        setTimeout(() => {
            if (segmentRecorder.state === "recording") {
                segmentRecorder.stop();
            }
        }, BUFFER_SECONDS * 1000);
    }

    // IMPORTANT: call it RIGHT HERE
    startSegmentRecorder();
    // -------------------------------


