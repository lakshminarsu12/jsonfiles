1. inside getUserMedia

function getFullVideoBlob() {
  if (!fullChunks.length) return null;
  return new Blob(fullChunks, { type: 'video/webm' });
}


async function extractLastSeconds(fullBlob, lastSeconds = 5) {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.style.display = 'none';
    video.muted = true;
    video.playsInline = true;

    document.body.appendChild(video);

    const url = URL.createObjectURL(fullBlob);
    video.src = url;

    video.onloadedmetadata = () => {
      try {
        const dur = video.duration;
        if (!isFinite(dur) || dur <= 0) {
          throw new Error('Invalid video duration');
        }

        const clipLen = Math.min(lastSeconds, dur);
        const startTime = Math.max(0, dur - clipLen);
        video.currentTime = startTime;

        video.onseeked = async () => {
          try {
            const stream = video.captureStream();
            const rec = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            const chunks = [];

            rec.ondataavailable = e => {
              if (e.data && e.data.size > 0) chunks.push(e.data);
            };

            rec.onstop = () => {
              const outBlob = new Blob(chunks, { type: 'video/webm' });
              URL.revokeObjectURL(url);
              document.body.removeChild(video);
              resolve(outBlob);
            };

            rec.start();
            await video.play();

            setTimeout(() => {
              if (rec.state === 'recording') rec.stop();
              video.pause();
            }, clipLen * 1000);
          } catch (err) {
            reject(err);
          }
        };
      } catch (err) {
        reject(err);
      }
    };

    video.onerror = () => reject(new Error('Error loading video for trimming'));
  });
}



async function handleRgConfirmedAndUpload() {
  if (rgHandled) return;   // safety guard
  rgHandled = true;

  console.log("RG confirmed: stopping recorder and extracting last 5 seconds");

  // 1) Stop the full recording
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
  }

  const fullBlob = getFullVideoBlob();
  if (!fullBlob) {
    console.warn("No full video data recorded");
    return;
  }

  try {
    // 2) Re-record last BUFFER_SECONDS from full video
    const last5Blob = await extractLastSeconds(fullBlob, BUFFER_SECONDS);

    // Optional: download locally for debugging
     const debugUrl = URL.createObjectURL(last5Blob);
     const a = document.createElement('a');
     a.href = debugUrl;
     a.download = 'last_5_seconds.webm';
     a.click();
     URL.revokeObjectURL(debugUrl);

    // 3) Convert to Base64 and upload to your Java API
    const reader = new FileReader();
    reader.onloadend = function () {
      const dataUrl = reader.result;              // data:video/webm;base64,...
      const base64Video = dataUrl.split(',')[1];  // strip prefix

      fetch('http://localhost:9990/iapi/v1/aiService/uploadVideo?ban=1234', {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: base64Video
      })
      .then(res => res.text())
      .then(t => console.log('Upload last 5s response:', t))
      .catch(err => console.error('Upload last 5s error:', err));
    };
    reader.readAsDataURL(last5Blob);
  } catch (err) {
    console.error('Error extracting last 5 seconds:', err);
  }
}
