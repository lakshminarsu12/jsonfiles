1. inside getUserMedia

function getFullVideoBlob() {
  if (!fullChunks.length) return null;
  return new Blob(fullChunks, { type: 'video/webm' });
}


async function extractLastSeconds(fullBlob, lastSeconds = 5) {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.style.display = 'none';
    video.muted = true;
    video.playsInline = true;

    document.body.appendChild(video);

    const url = URL.createObjectURL(fullBlob);
    video.src = url;

    // helper to get a reliable duration
    async function getRealDuration() {
      return new Promise((resolveDur, rejectDur) => {
        let tries = 0;

        function tryResolveDuration() {
          let d = video.duration;
          if (isFinite(d) && d > 0) {
            resolveDur(d);
            return;
          }

          if (tries > 0) {
            // after a seek, use currentTime as a fallback
            if (video.currentTime > 0 && isFinite(video.currentTime)) {
              resolveDur(video.currentTime);
              return;
            }
          }

          // Seek far into the future to force clamp at end
          tries++;
          video.currentTime = 1e9;  // big number
        }

        video.addEventListener('seeked', () => {
          let d = video.duration;
          if (isFinite(d) && d > 0) {
            resolveDur(d);
          } else if (video.currentTime > 0 && isFinite(video.currentTime)) {
            resolveDur(video.currentTime);
          } else if (tries < 3) {
            tryResolveDuration();
          } else {
            rejectDur(new Error('Unable to determine duration'));
          }
        }, { once: true });

        tryResolveDuration();
      });
    }

    video.onloadedmetadata = async () => {
      try {
        let dur = await getRealDuration();
        if (!isFinite(dur) || dur <= 0) {
          throw new Error('Duration still invalid after seeking');
        }

        const clipLen = Math.min(lastSeconds, dur);
        const startTime = Math.max(0, dur - clipLen);

        video.currentTime = startTime;

        video.onseeked = async () => {
          try {
            const stream = video.captureStream();
            const rec = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            const chunks = [];

            rec.ondataavailable = e => {
              if (e.data && e.data.size > 0) chunks.push(e.data);
            };

            rec.onstop = () => {
              const outBlob = new Blob(chunks, { type: 'video/webm' });
              URL.revokeObjectURL(url);
              document.body.removeChild(video);
              resolve(outBlob);
            };

            rec.start();
            await video.play();

            setTimeout(() => {
              if (rec.state === 'recording') rec.stop();
              video.pause();
            }, clipLen * 1000);
          } catch (err) {
            reject(err);
          }
        };
      } catch (err) {
        URL.revokeObjectURL(url);
        document.body.removeChild(video);
        reject(err);
      }
    };

    video.onerror = () => {
      URL.revokeObjectURL(url);
      document.body.removeChild(video);
      reject(new Error('Error loading video for trimming'));
    };
  });
}




async function handleRgConfirmedAndUpload() {
  if (rgHandled) return;
  rgHandled = true;

  console.log("RG confirmed: stopping recorder and extracting last 5 seconds");

  // 1) Wait for recorder to fully stop and flush last chunk
  if (mediaRecorder && mediaRecorder.state === "recording") {
    await new Promise(resolve => {
      mediaRecorder.addEventListener('stop', () => resolve(), { once: true });
      mediaRecorder.stop();
    });
  }

  const fullBlob = getFullVideoBlob();
  if (!fullBlob) {
    console.warn("No full video data recorded");
    return;
  }

  try {
    const last5Blob = await extractLastSeconds(fullBlob, BUFFER_SECONDS);

    // Optional: debug download
    const debugUrl = URL.createObjectURL(last5Blob);
    const a = document.createElement('a');
    a.href = debugUrl;
    a.download = 'last_5_seconds.webm';
    a.click();
    URL.revokeObjectURL(debugUrl);

    // Upload as Base64
    const reader = new FileReader();
    reader.onloadend = function () {
      const dataUrl = reader.result;              // data:video/webm;base64,...
      const base64Video = dataUrl.split(',')[1];  // strip prefix

      fetch('http://localhost:9990/iapi/v1/aiService/uploadVideo?ban=1234', {
        method: 'POST',
        headers: { 'Content-Type': 'text/plain' },
        body: base64Video
      })
      .then(res => res.text())
      .then(t => console.log('Upload last 5s response:', t))
      .catch(err => console.error('Upload last 5s error:', err));
    };
    reader.readAsDataURL(last5Blob);
  } catch (err) {
    console.error('Error extracting last 5 seconds:', err);
  }
}

